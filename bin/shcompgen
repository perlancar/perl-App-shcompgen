#!perl

# DATE
# VERSION
# FRAGMENT id=shcompgen-nohint

use 5.010;
use strict;
use warnings;
use experimental 'smartmatch';

use App::shcompgen;
use Perinci::CmdLine::Any;

my $urlprefix = '/App/shcompgen/';
Perinci::CmdLine::Any->new(
    url => $urlprefix,
    log => $ENV{LOG} // 1,
    subcommands => {
        init     => {url=>"${urlprefix}init"},
        generate => {url=>"${urlprefix}generate"},
        list     => {url=>"${urlprefix}list"},
        remove   => {url=>"${urlprefix}remove"},

        'guess-shell' => {url=>"${urlprefix}guess_shell", summary => "(Utility) detect a program", tags=>["category:utility"]},
        'detect-prog' => {url=>"${urlprefix}detect_prog", summary => "(Utility) Guess running shell", tags=>["category:utility"]},
    },
)->run;

# ABSTRACT:
# PODNAME:

=head1 SYNOPSIS

Initialize (this will create completion scripts directory, create shell script
to initialize completion system):

 % shcompgen init

Generate shell completion scripts for all detectable programs in PATH:

 % shcompgen generate

Note that this distribution automatically runs 'init' and 'generate' the first
time it is installed, or when you upgrade from an older version. So normally you
don't have to do this manually.

Generate some programs only, replace if previously already exists, be verbose:

 % shcompgen generate --verbose --replace prog1 prog2 ./bin/prog3

List all shell completion scripts generated by us:

 % shcompgen list
 % shcompgen list --detail

Remove some shell completion scripts:

 % shcompgen remove prog1 prog2

Remove all generated shell completion scripts:

 % shcompgen remove


=head1 DESCRIPTION

Some shells, like bash/fish/zsh, supports tab completion for programs. They are
usually activated by issuing one or more C<complete> (zsh uses C<compctl>)
internal shell commands. The completion scripts which contain these commands are
usually put in (e.g., for fish) C</etc/fish/completion/PROGNAME.fish> (if one
wants to install globally) or C<~/.config/fish/completions/PROGNAME.fish> (if
one wants to install per-user).

This utility, B<shcompgen>, can detect how to generate shell completion scripts
for some programs and then install the completion scripts into the
abovementioned location (the default is to per-user directory, but if running as
root or with C<--global> switch will install to the global directory).

It can also list all completion scripts generated by it, and be instructed to
uninstall them again.

It supports several shells, currently: bash, fish, and zsh. Shell-specific
information can be found below.

=head2 bash-specific information

This script can work with the C<bash-completion> package (and uses the same
global completion directory: C</etc/bash_completion.d>). At the time of this
writing, bash-completion (at version 2.1) does not yet look at per-user
completion scripts directory. This script picks
C<~/.config/bash/completions/PROGNAME> as location for per-user completion
scripts. If later on C<bash-completion> package decides on a different per-user
location, this script will probably be adjusted too.

=head2 fish-specific information

Support for fish is rather new. There might be bugs. Some scripts have not been
supported, e.g. L<Getopt::Long::Subcommand>-based scripts or
L<Perinci::CmdLine>-based scripts which have subcommands.

=head2 tcsh-specific information

So far I couldn't get fallback (a.k.a catch-all) completion mechanism to work in
tcsh. For example if I do:

 complete '*' 'p/*/`helper`/'

then it will eclipse the other existing completion definitions.

So in tcsh, activating (or deactivating) completion is currently less convenient
compared to the other shells. Instead of the C<complete> definitions being put on
a per-command basis in C<~/.config/tcsh/completions/> directory, the init script
C<~/.config/shcompgen.tcsh> will directly contain all the C<complete>
definitions. This script must be sourced to update the definitions. So after you

 % shcompgen generate foo

you will need to re-source the init script (or logout from + login back to the
shell). And after you remove a completion script, you will need to C<uncomplete>
+ re-source the init script (or logout from + login back to the shell).

=head2 zsh-specific information

=head2 Program detection

Below are the types/kinds of programs that can be detected. Expect the list to
expand as more methods are added.

=over

=item * Scripts which are tagged with hints of what completion program to use

You can put this line in a script, e.g. in a script called C<foo>:

 # FRAGMENT id=shcompgen-hint command=bar

The above line tells C<shcompgen> that the script should be completed using an
external program called C<bar>. This will construct this completion script, e.g.
for bash:

 complete -C bar foo

=item * Completion programs which are tagged with hints of what programs they complete

You can create a completion script in Perl (or other language, actually), e.g.
C<_foo> and tag it with hints of what programs they complete, e.g.

 # FRAGMENT id=shcompgen-hint completer=1 for=foo,foo-this-host

This will add completion script for C<foo>:

 complete -C _foo foo

as well as for C<foo-this-host>:

 complete -C _foo foo-this-host

=item * Getopt::Long::Complete-based CLI scripts

If a script C<foo> is detected as a Perl script using L<Getopt::Long::Complete>,
we know that it can complete itself. Thus, C<shcompgen> will generate this
completion script (e.g. for bash):

 complete -C foo foo

=item * Getopt::Long::Subcommand-based CLI scripts

If a script C<foo> is detected as a Perl script using
L<Getopt::Long::Subcommand>, we know that it can complete itself. Thus,
C<shcompgen> will generate this completion script (e.g. for bash):

 complete -C foo foo

=item * Perinci::CmdLine-based CLI scripts

If a script like C<foo> is detected as a Perl script using L<Perinci::CmdLine>
(or its variant like L<Perinci::CmdLine::Lite> or L<Perinci::CmdLine::Any>) we
know that it can complete itself. Thus, C<shcompgen> will add this completion
script e.g. for bash:

 complete -C foo foo

=item * Other methods

Other methods will be added in the future, e.g. by parsing manpage or POD, and
so on.

=back


=head1 SEE ALSO

L<Dist::Zilla::Plugin::GenShellCompletion>
