#!perl

# DATE
# VERSION
# FRAGMENT id=shcompinst-nohint

use 5.010;
use strict;
use warnings;

use App::ShellCompletionInstaller;
use Perinci::CmdLine::Any -prefer_lite=>1;

our %SPEC;

sub _all_exec_in_PATH {
    my @res;
    for my $dir (split /:/, $ENV{PATH}) {
        opendir my($dh), $dir or next;
        for my $f (readdir $dh) {
            next if $f eq '.' || $f eq '..';
            next if $f =~ /~\z/; # skip backup files
            next unless ((-f "$dir/$f") && (-x _));
            push @res, "$dir/$f";
        }
    }
    \@res;
}

$SPEC{installer} = {
    v => 1.1,
    summary => 'Shell completion installer',
    args => {
        action => {
            schema => 'str*',
            cmdline_aliases => {
                list       => { is_flag=>1, code=>sub { $_[0]{action} = 'list' } },
                l          => { is_flag=>1, code=>sub { $_[0]{action} = 'list' } },
                clean      => { is_flag=>1, code=>sub { $_[0]{action} = 'clean' } },
                uninstall  => { is_flag=>1, code=>sub { $_[0]{action} = 'uninstall' } },
                u          => { is_flag=>1, code=>sub { $_[0]{action} = 'uninstall' } },
            },
            default => 'install',
        },
        detail => {
            schema => 'bool*',
        },
        replace => {
            schema => 'bool*',
        },
       args => {
            schema => ['array*' => of => 'str*'],
            pos    => 0,
            greedy => 1,
        },
    },
};
sub installer {
    my %args = @_;

    my $action = $args{action};
    my $args   = $args{args};

    if ($action eq 'add') {
        $args = _all_exec_in_PATH() unless $args;
        return App::ShellCompletionInstaller::_install(
            file    => $args{file},
            progs   => $args,
            replace => $args{replace},
        );
    } elsif ($action eq 'list') {
        return App::ShellCompletionInstaller::_list(
            file    => $args{file},
            detail  => $args{detail},
        );
    } elsif ($action eq 'clean') {
        return App::ShellCompletionInstaller::_clean(
            file    => $args{file},
        );
    } elsif ($action eq 'uninstall') {
        $args = _all_exec_in_PATH() unless $args;
        return App::ShellCompletionInstaller::_uninstall(
            file    => $args{file},
            progs   => $args,
        );
    }
}

Perinci::CmdLine::Any->new(
    url => '/main/installer',
    log => 1,
)->run;

# ABSTRACT: Shell completion installer
# PODNAME: shell-completion-installer

=head1 SYNOPSIS

Detect completion for all programs in PATH and install completion scripts for
all detectable programs:

 % shell-completion-installer

Detect some programs only, replace if previously already exists:

 % shell-completion-installer --replace prog1 prog2 ./bin/prog3

List all programs whose completion scripts are installed by us:

 % shell-completion-installer -l

Uninstall (delete completion scripts) for some programs:

 % shell-completion-installer -u prog1 prog2

Uninstall all:

 % shell-completion-installer -u


=head1 DESCRIPTION

Some shells, like bash/fish/zsh, supports tab completion for programs. They are
usually activated by issuing one or more C<complete> (zsh uses C<compctl>)
internal shell commands. The completion scripts which contain these commands are
usually put in (e.g., for fish) C</etc/fish/completion/PROGNAME.fish> (if want
to be installed globally) or C<~/.config/fish/completions/PROGNAME.fish> (if
want to be installed per-user).

This utility, B<shell-completion-installer>, can detect how to generate
completion scripts for some programs and then install the completion scripts
into the abovementioned location.

It can also list all completion scripts generated by it, and be instructed to
remove them again.

It supports several shells, currently: bash, fish, tcsh, and zsh. Shell-specific
information can be found below.

=head2 Setup for bash

Put these lines in your C</etc/bash.bashrc> or C<~/.bashrc>:

# EXAMPLE: share/init-bash

B<If you are using bash-completion package>: At the time of this writing,
bash-completion (at 2.1) does not yet look at per-user completion scripts
directory, only in C</etc/bash_completion.d/>, so you might still want to
install the above in your C</etc/bash.bashrc> or C<~/.bashrc>:

=head2 Setup for fish

=head2 Setup for tcsh

=head2 Setup for zsh

=head2 Program detection

Below are the types/kinds of programs that can be detected. Expect the list to
expand as more methods are added.

=over

=item * Scripts which are tagged with hints of what completion program to use

You can put this line in a script, e.g. in a script called C<foo>:

 # FRAGMENT id=shcompinst-hint command=bar

The above line tells C<shell-completion-installer> that the script should be
completed using an external program called C<bar>. This will construct this
completion script, e.g. for bash:

 complete -C bar foo

=item * Getopt::Long::Complete-based CLI scripts

If a script like C<foo> is detected as a Perl script using
L<Getopt::Long::Complete>, we know that it can complete itself. Thus,
C<shell-completion-installer> will generate this completion script (e.g. for
bash):

 complete -C foo foo

=item * Completion programs which are tagged with hints of what programs they complete

You can create a completion script in Perl (or other language, actually), e.g.
C<_foo> and tag it with hints of what programs they complete, e.g.

 # FRAGMENT id=shcompinst-hint completer=1 for=foo,foo-this-host

This will add completion script for C<foo>:

 complete -C _foo foo

as well as for C<foo-this-host>:

 complete -C _foo foo-this-host

=item * Perinci::CmdLine-based CLI scripts

If a script like C<foo> is detected as a Perl script using L<Perinci::CmdLine>
(or its variant like L<Perinci::CmdLine::Lite> or L<Perinci::CmdLine::Any>) we
know that it can complete itself. Thus, C<shell-completion-installer> will add
this completion script e.g. for bash:

 complete -C foo foo

=item * Other methods

Other methods will be added in the future, e.g. by parsing manpage or POD, and
so on.

=back

=head2 Usage

The simplest usage would be to call the program without any argument, which will
scan all programs found in C<PATH> and add completion scripts for all
recognizable programs.

 % shell-completion-installer

Or you can add individual programs. Program names without directory (without
C</>) will be searched in C<PATH>. If you want to add program in the current
directory, use C<./progname> syntax.

 % shell-completion-installer foo ./bar/baz

If a program's completion cannot be determined, it will simply be ignored. If a
program's completion script already exists, it will also be ignored, unless
C<--replace> is specified.


=head1 OPTIONS

=head2 --shell=s, -s

Select a specific shell. By default the running shell (detected from the
C<SHELL> environment variable) is used.

=head2 --list, -l

List all programs we generate completion scripts for.

=head2 --clean

Uninstall all completion scripts generated by C<shell-completion-installer>
for all commands that are no longer found in PATH.

=head2 --uninstall, -u

Remove all completion scripts generated by us for specified programs, or (if
unspecified) all programs.

=head2 --replace

When completion script for a program already exists,
C<shell-completion-installer> will skip the program. Unless when this option is
specified, in which case it will replace the completion script with the newly
generated one.


=head1 ENVIRONMENT

=head2 DEBUG => bool

Set to true to enable debugging messages.


=head1 TODO


=head1 SEE ALSO

L<Dist::Zilla::Plugin::Rinci::InstallCompletion>
