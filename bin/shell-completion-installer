#!perl

# DATE
# VERSION
# FRAGMENT id=shcompinst-nohint

use 5.010;
use strict;
use warnings;

use App::ShellCompletionInstaller;
use Perinci::CmdLine::Any -prefer_lite=>1;

our %SPEC;

sub _all_exec_in_PATH {
    my @res;
    for my $dir (split /:/, $ENV{PATH}) {
        opendir my($dh), $dir or next;
        for my $f (readdir $dh) {
            next if $f eq '.' || $f eq '..';
            next if $f =~ /~\z/; # skip backup files
            next unless ((-f "$dir/$f") && (-x _));
            push @res, "$dir/$f";
        }
    }
    \@res;
}

$SPEC{installer} = {
    v => 1.1,
    summary => 'Shell completion installer',
    args => {
        action => {
            schema => 'str*',
            cmdline_aliases => {
                list       => { is_flag=>1, code=>sub { $_[0]{action} = 'list' } },
                l          => { is_flag=>1, code=>sub { $_[0]{action} = 'list' } },
                clean      => { is_flag=>1, code=>sub { $_[0]{action} = 'clean' } },
                uninstall  => { is_flag=>1, code=>sub { $_[0]{action} = 'uninstall' } },
                u          => { is_flag=>1, code=>sub { $_[0]{action} = 'uninstall' } },
            },
            default => 'install',
        },
        detail => {
            schema => 'bool*',
        },
        replace => {
            schema => 'bool*',
        },
       args => {
            schema => ['array*' => of => 'str*'],
            pos    => 0,
            greedy => 1,
        },
    },
};
sub installer {
    my %args = @_;

    my $action = $args{action};
    my $args   = $args{args};

    if ($action eq 'add') {
        $args = _all_exec_in_PATH() unless $args;
        return App::ShellCompletionInstaller::_install(
            file    => $args{file},
            progs   => $args,
            replace => $args{replace},
        );
    } elsif ($action eq 'list') {
        return App::ShellCompletionInstaller::_list(
            file    => $args{file},
            detail  => $args{detail},
        );
    } elsif ($action eq 'clean') {
        return App::ShellCompletionInstaller::_clean(
            file    => $args{file},
        );
    } elsif ($action eq 'uninstall') {
        $args = _all_exec_in_PATH() unless $args;
        return App::ShellCompletionInstaller::_uninstall(
            file    => $args{file},
            progs   => $args,
        );
    }
}

Perinci::CmdLine::Any->new(
    url => '/main/installer',
    log => 1,
)->run;

# ABSTRACT: Shell completion installer
# PODNAME: shell-completion-installer

=head1 SYNOPSIS

Detect completion for all programs in PATH and install completion scripts for
all detectable programs:

 % shell-completion-installer

Detect some programs only, replace if previously already exists:

 % shell-completion-installer --replace prog1 prog2 ./bin/prog3

List all programs whose completion scripts are installed by us:

 % shell-completion-installer -l

Uninstall (delete completion scripts) for some programs:

 % shell-completion-installer -u prog1 prog2

Uninstall all:

 % shell-completion-installer -u


=head1 DESCRIPTION

Some shells, like bash/fish/zsh, supports tab completion for programs. They are
usually activated by issuing one or more C<complete> (zsh uses C<compctl>)
internal shell commands. The completion scripts which contain these commands are
usually put in (e.g., for fish) C</etc/fish/completion/PROGNAME.fish> (if want
to be installed globally) or C<~/.config/fish/completions/PROGNAME.fish> (if
want to be installed per-user).

This utility, B<shell-completion-installer>, can detect how to generate
completion scripts for some programs and then install the completion scripts
into the abovementioned location (the default is to per-user directory, but
under C<--global> will install to the global directory).

It can also list all completion scripts generated by it, and be instructed to
remove them again.

It supports several shells, currently: bash, fish, and zsh. Shell-specific
information can be found below.

=head2 Setup for bash

If you have installed this distribution on your system, you should have a file
called C<init-bash> somewhere in your system, e.g. in
C</usr/local/share/perl/X.Y.Z/auto/share/dist/App-ShellCompletionInstaller/init-bash>.
You then need to load this file from you C</etc/bash.bashrc> or C<~/.bashrc>,
e.g.:

 . /usr/local/share/perl/X.Y.Z/auto/share/dist/App-ShellCompletionInstaller/init-bash

B<If you are using bash-completion package>: At the time of this writing,
bash-completion (at 2.1) does not yet look at per-user completion scripts
directory (e.g. C<~/.config/bash/completions/PROGNAME>, only in
C</etc/bash_completion.d/>, so you might still want to put the above in your
C</etc/bash.bashrc> or C<~/.bashrc>. The above init script works with
bash-completion package installed.

For completeness sake, this is the content of the C<init-bash> script:

# EXAMPLE: share/init-bash

=head2 Setup for fish

No setup is necessary for fish. By default fish already looks in
C<~/.config/fish/completions/PROGNAME.fish> and
C</etc/fish/completions/PROGNAME.fish> (although configurable via
C<$fish_complete_path>) so C<shell-completion-installer> only needs to put
completion scripts there.

=head2 Setup for zsh

Depending on your configuration, by default zsh's C<FPATH> doesn't contain
per-user directory. You can put this line in your C<~/.zshrc>:

 export FPATH="~/.config/zsh/completions:$FPATH"

=head2 Program detection

Below are the types/kinds of programs that can be detected. Expect the list to
expand as more methods are added.

=over

=item * Scripts which are tagged with hints of what completion program to use

You can put this line in a script, e.g. in a script called C<foo>:

 # FRAGMENT id=shcompinst-hint command=bar

The above line tells C<shell-completion-installer> that the script should be
completed using an external program called C<bar>. This will construct this
completion script, e.g. for bash:

 complete -C bar foo

=item * Getopt::Long::Complete-based CLI scripts

If a script like C<foo> is detected as a Perl script using
L<Getopt::Long::Complete>, we know that it can complete itself. Thus,
C<shell-completion-installer> will generate this completion script (e.g. for
bash):

 complete -C foo foo

=item * Completion programs which are tagged with hints of what programs they complete

You can create a completion script in Perl (or other language, actually), e.g.
C<_foo> and tag it with hints of what programs they complete, e.g.

 # FRAGMENT id=shcompinst-hint completer=1 for=foo,foo-this-host

This will add completion script for C<foo>:

 complete -C _foo foo

as well as for C<foo-this-host>:

 complete -C _foo foo-this-host

=item * Perinci::CmdLine-based CLI scripts

If a script like C<foo> is detected as a Perl script using L<Perinci::CmdLine>
(or its variant like L<Perinci::CmdLine::Lite> or L<Perinci::CmdLine::Any>) we
know that it can complete itself. Thus, C<shell-completion-installer> will add
this completion script e.g. for bash:

 complete -C foo foo

=item * Other methods

Other methods will be added in the future, e.g. by parsing manpage or POD, and
so on.

=back

=head2 Usage

The simplest usage would be to call the program without any argument, which will
scan all programs found in C<PATH> and add completion scripts for all
recognizable programs.

 % shell-completion-installer

Or you can add individual programs. Program names without directory (without
C</>) will be searched in C<PATH>. If you want to add program in the current
directory, use C<./progname> syntax.

 % shell-completion-installer foo ./bar/baz

If a program's completion cannot be determined, it will simply be ignored. If a
program's completion script already exists, it will also be ignored, unless
C<--replace> is specified.


=head1 OPTIONS

=head2 --global

Instead of

=head2 --shell=s, -s

Select a specific shell. By default the running shell (detected from the
C<SHELL> environment variable) is used.

=head2 --list, -l

List all programs we generate completion scripts for.

=head2 --clean

Uninstall all completion scripts generated by C<shell-completion-installer>
for all commands that are no longer found in PATH.

=head2 --uninstall, -u

Remove all completion scripts generated by us for specified programs, or (if
unspecified) all programs.

=head2 --replace

When completion script for a program already exists,
C<shell-completion-installer> will skip the program. Unless when this option is
specified, in which case it will replace the completion script with the newly
generated one.


=head1 ENVIRONMENT

=head2 DEBUG => bool

Set to true to enable debugging messages.


=head1 TODO

Support for tcsh.


=head1 SEE ALSO

L<Dist::Zilla::Plugin::Rinci::InstallCompletion>
